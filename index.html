<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>AKKA cluster for scalania</title>

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>AKKA Cluster</h1>
					<h3>Warsaw Scala Enthusiasts Meetup</h3>
					<p>
						<small>By Tomasz Kogut / <a href="http://twitter.com/almendar">@almendar</a></small>
					</p>
					<p>2015.03.18</p> 
				</section>
				<section>
					<section>
						<h3>What a <i>'cluster'</i> means in terms of AKKA?</h2>
						<p class="fragment">A set of nodes with a membership service</p>
						<p class="fragment">AKKA clustering is NOT about <b>fail-over</b> or <b>replication</b>
					</section>
					<section>
						<h3>Spread your AKKA application across multiple machines</h3>
						<object data="img/1.svg" type="image/svg+xml"></object>
					</section>
				</section>
				<section>
					<section>
						<h2>How does it works?</h2>
						<ul>
							<li>Gossip protocol used to propagate information about membership</li>
							<li>One of the nodes takes the role of the leader - shifts nodes in&amp;out of the cluster</li>
							<li>Nodes are always in some state:</li>
						</ul>
					</section>
					<section>
						<p>Leader changes the nodes state</p>
						<img src="img/member-states.png"/>
						<p>Only state that can be recovered from is 'unreachable'</p>
						<p>If you go out there is no commin' back!</p>
					</section>
					<section>
						<h3>Failure detection</h3>
						<p>In case any of the nodes becomes unreachable convergence is not possible</p>
						<ul>
							<li>No new nodes can join the cluster</li>
							<li>
								Problematic node may:
								<ul>
									<li>be detected as reachable again so the cluster can proceed</li>
									<li>be removed by the leader by setting auto-down option after set interval</li>
								</ul>
							</li>
							<li>
								Auto removal of unreachable nodes may cause creation of many little clusters.
							</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>Preparing your project for clustering</h2>
					</section>
					<section>
							<p>dependencies</p>
							<pre><code>"com.typesafe.akka" %% "akka-cluster" % "x.x.x"</code></pre>
							<p>application.conf</p>
							<pre><code data-trim>
akka {
	actor { provider = "akka.cluster.ClusterActorRefProvider" }
	remote {
		log-remote-lifecycle-events = off
		netty.tcp {
			hostname = "ip_address"
			port = 0
		}
	}
	cluster {
		seed-nodes = [
			"akka.tcp://ClusterSystem@machine1:2551",
			"akka.tcp://ClusterSystem@machine2:2552"]
		auto-down-unreachable-after = 10s
	}
}
		    				</code></pre>
	    			</section>
	    			<section>
	    				<h3>Changes</h3>
	    				<ul>
	    					<li>Actor ref provider, ActorRef still stays smart</li>
	    					<li>Seed nodes, any node will do</li>
	    					<li>Network address to bind</li>
	    				</ul>
	    			</section>
				</section>
				<section>
					<section>
						<h2>Making use of akka cluster</h2>
					</section>
					<section>
						<h3>Some actors need to be made aware of the cluster</h3>
						<ul>
							<li>In most cases there will be nothing specific to clustering in your code</li>
							<li>Distribution of actors isn't automagical</li>
							<li>Try to separate how work is distributed from how the work is done</li>
						</ul>
					</section>
					<section>
					<h3>Listening for cluster events</h3>
						<pre><code data-trim>
class SimpleClusterListener extends Actor with ActorLogging {
	val cluster = Cluster(context.system)

	override def preStart(): Unit = {
		cluster.subscribe(self, initialStateMode = 
		InitialStateAsEvents,
		classOf[MemberEvent], classOf[UnreachableMember])
	}
	override def postStop(): Unit = cluster.unsubscribe(self)
	def receive = {
		case state: CurrentClusterState =>
		case MemberUp(member) =>
		case UnreachableMember(member) =>
		case MemberRemoved(member, previousStatus) =>
		case _: MemberEvent =>
	}
}
						</code></pre>
					</section>
					<section>
						<h4>Making use of members information</h4>
						<br/>
						<p>Selecting remote actor</p>
						<pre><code data-trim>context.actorSelection(RootActorPath(member.address) 
						/ "user" / "frontend")</code></pre>
						<p>Creating actor on a remote node</p>
						<pre><code data-trim>
system.actorOf(Props[SampleActor]
	.withDeploy(Deploy(scope = RemoteScope(member.address))))
						</code></pre>
						<p>Using remote actorRefs</p>
						<pre><code data-trim>
actorRef ! "message" //transparent if acquired properly
						</code></pre>
					</section>
					<section>
						<h3>How to acquire an ActorRef?</h3>
						<ul>
							<li>Get it sent with a message</li>
							<li>Using actor selection
								<pre><code data-trim>def resolveOne(timeout: FiniteDuration): 
	Future[ActorRef]</code></pre>
							</li>
							<li>Using context methods
								<pre><code data-trim>
val parent : ActorRef = context.parent
val children: Iterable[ActorRef] = 
	context.children
							</code></li>
						</ul>
						<p>Don't use local selection paths. They are missing the address part</p>
						<pre><code>context.actorSelection("/user/actorName") //won't work</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Goodies</h2>
					</section>
					<section>
						<h3>Death watch</h3>
						<p>Works the same way as it would in a non-cluster mode</p>
						<pre><code>context.watch(actorRef) 
context.watch(actorSelection) &lt;- can't do this</code></pre>

						<p>Notice that dead child is not handled by the supervision strategy</p>
					</section>
					<section>
						<h3>Configuration deployment</h3>
						<pre><code>
akka {
  actor {
    deployment {
	  /sampleActor {
        remote = "akka.tcp://sampleActorSystem@127.0.0.1:2553"
      }
    }
  }
}
						</code></pre>
						<pre><code>
    val actor = system.actorOf(Props[SampleActor], "sampleActor")
    actor ! "Pretty slick"
    					</code></pre>
    					<p>Remember that jar with that class is needed</p>
					</section>
					<section>
						<h3>Minimum cluster size</h3>
						<pre><code>akka.cluster.min-nr-of-members = 3</code></pre>
					</section>
					<section>
						<h3>Roles</h3>
						<ul>
							<li>A way to group your servers by different tasks they serve (e.g. UI, data access layer, numbers cruncher)</li>
							<li>Any node can connect and claim what its role is</li>
							<li>This information is available in member events</li>
							<br/>
							<pre><code>akka.cluster.roles = [compute]</code></pre>
							<pre><code>
override def receive: Receive = {
  case MemberUp(member) if(member.hasRole("compute")) => 
  (...)
}
							</code></pre>
						</ul>
					</section>
					<section>
						<h3>Minimum cluster size with roles</h3>
						<pre><code>
akka.cluster.role {
  frontend.min-nr-of-members = 1
  backend.min-nr-of-members = 2
}
						</code></pre>
					</section>
					<section>
						<h3>External contributions</h3>
						<ul>
							<li><b>Cluster Singleton</b> - exactly one actor of a certain type running somewhere in the cluster</li>
							<li><b>Cluster Sharding</b> - distribute actors across several nodes in the cluster and want to be able to interact with them using their logical identifier</li>
							<li><b>Distributed Publish Subscribe</b> - registry of actors</li>
							<li><b>Cluster Client</b> - actor can communicate with cluster being outside of the cluster</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h3>Cluster-aware routers</h3>
						<ul>
							<li>Group - router that sends messages to the specified path using actor selection</li>
							<li>Pool - router that creates routees as child actors and deploys them on remote nodes</li>
						</ul>
					</section>
					<section>
						<h3>Pool router</h3>
						<pre><code>
akka.actor.deployment {
  /statsService/workerRouter {
    router = consistent-hashing-group
    nr-of-instances = 100
    routees.paths = ["/user/statsWorker"]
    cluster {
      enabled = on
      allow-local-routees = on
      use-role = compute
    }
  }
}
</code></pre>
					</section>
					<section>
						<h3>Group router</h3>
						<pre><code>
akka.actor.deployment {
  /singleton/statsService/workerRouter {
  router = consistent-hashing-pool
  nr-of-instances = 100
  cluster {
    enabled = on
    max-nr-of-instances-per-node = 3
    allow-local-routees = on
    use-role = compute
  }
 }
}
						</code></pre>
					</section>
				</section>
				<section>
					<h3>How akka remoting and clustering relate?</h3>
					<ul>
						<li>Remoting is responsible for all the plumbing that takes care of the network communication</li>
						<li>akka-cluster is build on top of it</li>
						<li>There is probably no need to use remoting directly</li>
					</ul>
				</section>
				<section>
					<h3>Things not covered today:</h3>
					<ul>
						<li>Cluster metrics</li>
						<li>Testing (local and multi JVM)</li>
						<li>JMX managment</li>
						<li>Cluster distpacher (!!!)</li>
						<li>Message serialization</li>
					</ul>
				</section>
				<section>
					<h2>Credits</h2>
					<p>Many of the code examples and images were taken from the official akka documentation</p>
					<a href="http://akka.io/docs/" target="_blank">AKKA docs</a>
				</section>
				<section>
					<h1>Thank you!</h1>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
